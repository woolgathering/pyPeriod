"""
Dictionary functions.
"""

import numpy as np

# natural basis dictionary (Sethares and Staley)
def natural_row(p, s, repetitions=1):
  vec = np.zeros(p)
  for i in range(p):
    if (i-s)%p == 0:
      vec[i] = 1
  return np.tile(vec, repetitions)

# a complete natural basis
def natural_complete(p, N=1):
  repetitions = int(np.ceil(N/p))
  matrix = np.zeros((p, int(N)))
  for i in range(p):
    matrix[i] = natural_row(p, i, repetitions)[:int(N)]
  return matrix

def eulers_totient(n):
    amount = 0
    for k in range(1, n + 1):
        if np.gcd(n, k) == 1:
            amount += 1
    return amount

# Ramanujan sequence
def Cq(q, type='real'):
  vec = np.zeros(q, dtype=np.complex)
  k = []
  for i in range(q):
    i += 1
    v = np.gcd(i, q)
    if v==1:
      k.append(i)
  for i in range(q):
    for ii in k:
      vec[i] = vec[i] + np.exp(1j*2*np.pi*ii*i/q)

  if type=='real':
    return np.real(vec)
  elif type=='complex':
    return vec
  else:
    print ('Return type invalid, defaulting to \'real\'')
    return np.real(vec)

# complete Ramanujan matrix
def Cq_complete(q, N=None):
  if N is None:
    N = q # make it one period by default
  # et = eulers_totient(q)
  et = q
  matrix = np.zeros((et, int(N)))
  cq = Cq(q)
  for i in range(et):
    cq_rotated = np.roll(cq, i)
    repetitions = int(np.ceil(N/q))
    matrix[i] = np.tile(cq_rotated, repetitions)[:N]

  return matrix

def get_divisors(n):
  output = []
  for i in range(1, n+1):
    if (n%i) == 0:
      output.append(i)
  return np.array(output)

# get a matrix for a given period
def get_A(n, type='Natural'):
  matrix = np.zeros((n,n))
  divisors = get_divisors(n)
  index = 0
  for d in divisors:
    et = eulers_totient(d)
    if type=='Ramanujan':
      seq = Cq(d)
    elif type='Natural':
      seq = natural_row(d)
    else:
      raise ValueError('{} not an acceptable type.'.format(type))
    for i in range(et):
      repetitions = int(np.ceil(n/len(seq)))
      seq_rotated = np.roll(seq, i)
      matrix[index] = np.tile(seq_rotated, repetitions)[:n]
      index += 1
  return matrix

# get a diagonal matrix based on A
def get_D(A):
  matrix = np.zeros((A.shape))
  divisors = get_divisors(A.shape[0])
  index = 0 # index into the matrix
  for d in divisors:
    et = eulers_totient(d)
    for i in range(et):
      matrix[index][index] = d**2
      index += 1
  return matrix

def l2_norm(v):
    norm = np.linalg.norm(v)
    return v / norm

def inner_product(x, y):
  return np.sum(x*y)
